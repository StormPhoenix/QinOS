## 记录编程过程中遇到的一些问题

- [x] 编写进程之前，写了一个 TestProcess() 函数，这个函数当作一个进程来测试。中途
遇到一个语句 ``mov fs, ax`` 引起了 #GP fault，第一感觉很奇怪，这只是一个赋值语句而已
怎么会引起一个保护模式下的异常？

-  ``fs``是一个段寄存器，保护模式下给段寄存器赋值会从GDT或LDT里面预先读取段的属性
（参考概念：影子寄存器），如果当前的CPL\RPL不满足目的段的要求，会引发一个 #GP fault。

- [x] 用了三个进程 TestA、TestB、TestC （按照顺序放在一个数组里）测试多进程，调度
用轮转算法。经过一轮轮转后，发现所有的进程都在执行 TestC 的代码。

- 排查了GDT里面的TSS、TSS里面的LDT selector，数据都是对的，很奇怪。尝试各种方法无果
后准备先洗个澡。边洗边回顾 task switch 的整个流程，发现从内核态返回时会从 kernel stack
里面返回 eip，会不会某个地方写错了，导致三个进程使用的是同一个 kernel stack。经过排查，
发现在进程初始化设置堆栈时用的是 ``&task + PAGE_SIZE``，多加了一个&，修改成
``task + PAGE_SIZE`` 就可以了。

- [ ] 代码内定义了一个全局变量，并且赋值为0。但程序实际执行过程中，发现这个变量值是乱码，
但只要修改初值为除0外的其他值，就不会出现乱码现象。猜测是 i386-gcc 对初始值为0的变量有
什么特殊处理。

- [ ] invalid instruction suffix for `mov'
"movw   %%bx, %0\n\t"

- [ ] sti() 指令移动位置导致 #GP